---
// SECURITY: Server-side rendering for protected albums
// Photos are only fetched and rendered AFTER access is verified
export const prerender = false;

import { getAlbumByPath, getSubAlbums, getPhotosForAlbum, getArchiveFiles, buildBreadcrumbs, getAncestors, getAlbumCoverPhoto, getAlbumBody, parseInlineMarkdown, type ArchiveFile } from '../../lib/albums';
import Layout from '../../layouts/Layout.astro';
import SEO from '../../components/SEO.astro';
import AlbumGrid from '../../components/AlbumGrid.astro';
import PhotoGrid from '../../components/PhotoGrid.astro';
import Breadcrumbs from '../../components/Breadcrumbs.astro';
import Footer from '../../components/Footer.astro';
import { siteConfig } from '../../config';
// Note: PasswordProtection component no longer used - SSR form is inline

const { path } = Astro.params;
const { cookies } = Astro;

// Get album - redirect to 404 if not found
const album = await getAlbumByPath(path!);
if (!album) {
  return Astro.redirect('/404');
}

// Get token from query parameter (for share links)
const url = new URL(Astro.request.url);
const providedToken = url.searchParams.get('token');
const errorParam = url.searchParams.get('error');
const remainingAttempts = url.searchParams.get('remaining');

// Get photo parameter for individual photo sharing
const photoParam = url.searchParams.get('photo');

// Get ancestors for password inheritance checking
const ancestors = await getAncestors(path!);

// Check if album or any ancestor has password
const albumHasPassword = !!album.data.password;
const hasPasswordProtection = albumHasPassword || ancestors.some(a => !!a.data.password);

// SECURITY: Server-side access verification
let hasAccess = false;
let blockingAlbum: { path: string; title: string } | null = null;

if (!hasPasswordProtection) {
  // No password protection - grant access
  hasAccess = true;
} else {
  // Get unlocked tokens from cookie
  const accessCookie = cookies.get('album-access')?.value;
  let unlockedTokens: string[] = [];
  try {
    unlockedTokens = accessCookie ? JSON.parse(accessCookie) : [];
  } catch {
    unlockedTokens = [];
  }

  // Check if URL token grants access (share links)
  if (providedToken) {
    // Check if token matches this album
    if (providedToken === album.data.token && album.data.allowAnonymous !== false) {
      hasAccess = true;
      // Add to cookie for subsequent requests
      if (!unlockedTokens.includes(album.data.token)) {
        unlockedTokens.push(album.data.token);
        cookies.set('album-access', JSON.stringify(unlockedTokens), {
          httpOnly: true,
          secure: import.meta.env.PROD,
          sameSite: 'strict',
          maxAge: 60 * 60 * 24,
          path: '/'
        });
      }
    }
    // Check if token matches any ancestor
    if (!hasAccess) {
      for (const ancestor of ancestors) {
        if (providedToken === ancestor.data.token) {
          hasAccess = true;
          if (!unlockedTokens.includes(ancestor.data.token)) {
            unlockedTokens.push(ancestor.data.token);
            cookies.set('album-access', JSON.stringify(unlockedTokens), {
              httpOnly: true,
              secure: import.meta.env.PROD,
              sameSite: 'strict',
              maxAge: 60 * 60 * 24,
              path: '/'
            });
          }
          break;
        }
      }
    }
  }

  // Check cookie-based access
  if (!hasAccess) {
    // Check if this album's token is unlocked
    if (unlockedTokens.includes(album.data.token)) {
      hasAccess = true;
    } else {
      // Check ancestors - if any unlocked ancestor exists above a password-protected one, grant access
      let foundUnlockedAncestor = false;
      for (const ancestor of ancestors) {
        if (unlockedTokens.includes(ancestor.data.token)) {
          foundUnlockedAncestor = true;
          break;
        }
        if (ancestor.data.password) {
          // Found a password-protected ancestor that's not unlocked
          blockingAlbum = {
            path: ancestor.id.replace('/index.md', ''),
            title: ancestor.data.title
          };
          break;
        }
      }

      if (foundUnlockedAncestor) {
        hasAccess = true;
      } else if (!blockingAlbum && albumHasPassword) {
        // This album itself is blocking
        blockingAlbum = { path: path!, title: album.data.title };
      } else if (!blockingAlbum) {
        // No blocking ancestor found and album doesn't have password
        hasAccess = true;
      }
    }
  }
}

// SECURITY: Only fetch content if access is granted
let subAlbums: Awaited<ReturnType<typeof getSubAlbums>> = [];
let allMedia: Awaited<ReturnType<typeof getPhotosForAlbum>> = [];
let subAlbumsWithCovers: { album: typeof subAlbums[0]; coverPhotoUrl: string | null }[] = [];
let archiveFiles: ArchiveFile[] = [];

if (hasAccess) {
  subAlbums = await getSubAlbums(path!);
  allMedia = await getPhotosForAlbum(path!);
  archiveFiles = await getArchiveFiles(path!);

  // Fetch cover photos for sub-albums
  subAlbumsWithCovers = await Promise.all(
    subAlbums.map(async (subAlbum) => {
      const subAlbumPath = subAlbum.id.replace('/index.md', '');
      const coverPhotoUrl = await getAlbumCoverPhoto(subAlbumPath, subAlbum.data.thumbnail);
      return { album: subAlbum, coverPhotoUrl };
    })
  );
}

const breadcrumbs = buildBreadcrumbs(path!);
const bodyHtml = await getAlbumBody(path!);
const descriptionHtml = parseInlineMarkdown(album.data.description || '');

// Counts (only meaningful if hasAccess)
const photos = allMedia;
const photoCount = allMedia.filter(m => !m.isVideo).length;
const videoCount = allMedia.filter(m => m.isVideo).length;
const hasVideos = videoCount > 0;
const isCollection = album.data.isCollection || subAlbums.length > 0;

// ============ SEO / Social Sharing Meta Tags ============
let ogImage = siteConfig.defaultOgImage;
let ogTitle = album.data.title;
let ogDescription = album.data.description || `Photo album: ${album.data.title}`;
let noIndex = false;

if (!hasAccess) {
  // Protected album without access - don't expose any content
  noIndex = true;
  ogImage = '/images/og-locked.jpg';
  ogDescription = 'This album is password protected';
} else {
  // User has access - determine appropriate OG image

  // Check for individual photo sharing via ?photo= parameter
  if (photoParam && siteConfig.features.enablePhotoSharing) {
    const sharedMedia = allMedia.find(m => m.filename === photoParam);
    if (sharedMedia) {
      if (sharedMedia.isVideo) {
        // Videos use album cover as fallback
        ogTitle = `Video: ${sharedMedia.filename}`;
        ogDescription = `Video from ${album.data.title}`;
        const albumCover = await getAlbumCoverPhoto(path!, album.data.thumbnail);
        if (albumCover) {
          const coverPath = albumCover.replace('/albums/', '');
          ogImage = `/api/thumbnail?path=${encodeURIComponent(coverPath)}&size=large`;
        }
      } else {
        // Photo - use that specific photo as OG image
        ogTitle = `Photo from ${album.data.title}`;
        ogDescription = sharedMedia.filename;
        ogImage = `/api/thumbnail?path=${encodeURIComponent(`${path}/${sharedMedia.filename}`)}&size=large`;
      }
    }
  } else if (isCollection && subAlbumsWithCovers.length > 0) {
    // Collection: use first sub-album's cover photo
    const firstCover = subAlbumsWithCovers[0].coverPhotoUrl;
    if (firstCover) {
      const coverPath = firstCover.replace('/albums/', '');
      ogImage = `/api/thumbnail?path=${encodeURIComponent(coverPath)}&size=large`;
    }
  } else {
    // Regular album: use album's cover photo
    const albumCover = await getAlbumCoverPhoto(path!, album.data.thumbnail);
    if (albumCover) {
      const coverPath = albumCover.replace('/albums/', '');
      ogImage = `/api/thumbnail?path=${encodeURIComponent(coverPath)}&size=large`;
    }
  }
}
---

<Layout title={album.data.title}>
  <SEO
    slot="head"
    title={ogTitle}
    description={ogDescription}
    image={ogImage}
    imageWidth={1920}
    imageHeight={1280}
    noIndex={noIndex}
  />

  <div class="container">
    <Breadcrumbs items={breadcrumbs} />

    <div class="album-header">
      <h1>{album.data.title}</h1>
      {descriptionHtml && (
        <p class="album-description" set:html={descriptionHtml} />
      )}
      {album.data.date && (
        <p class="date">
          {(() => {
            const d = new Date(album.data.date);
            const day = d.getDate().toString().padStart(2, '0');
            const month = (d.getMonth() + 1).toString().padStart(2, '0');
            const year = d.getFullYear();
            return `${day}.${month}.${year}`;
          })()}
        </p>
      )}
      {album.data.tags && album.data.tags.length > 0 && (
        <div class="tags">
          {album.data.tags.map(tag => (
            <span class="tag">{tag}</span>
          ))}
        </div>
      )}
      {bodyHtml && (
        <article class="album-body prose" set:html={bodyHtml} />
      )}
    </div>

    <div class="album-content" id="album-content"
         data-album-path={path}
         data-album-token={album.data.token}
         data-has-access={hasAccess}
         data-shared-photo={photoParam || ''}>

      {/* SECURITY: Show password form only when access is denied */}
      {!hasAccess && hasPasswordProtection && (
        <div class="password-protection">
          <div class="password-form">
            <div class="lock-icon">ðŸ”’</div>
            <h2>This album is password protected</h2>
            <p>Please enter the password to view the photos</p>

            {/* Show which album is blocking access */}
            {blockingAlbum && blockingAlbum.path !== path && (
              <p class="blocking-info">
                Access blocked by: <strong>{blockingAlbum.title}</strong>
              </p>
            )}

            {/* Error messages from URL params */}
            {errorParam === 'wrong-password' && (
              <p class="error-message">
                Incorrect password.
                {remainingAttempts && parseInt(remainingAttempts) > 0 && (
                  <span>{remainingAttempts} attempts remaining.</span>
                )}
              </p>
            )}
            {errorParam === 'rate-limited' && (
              <p class="error-message">Too many attempts. Please try again in 15 minutes.</p>
            )}

            <form method="POST" action="/api/unlock">
              <input type="hidden" name="albumPath" value={blockingAlbum?.path || path} />
              <input type="hidden" name="returnUrl" value={`/photos/${path}`} />
              <input
                type="password"
                name="password"
                placeholder="Enter password"
                autocomplete="off"
                required
              />
              <button type="submit">Unlock Album</button>
            </form>
          </div>
        </div>
      )}

      {/* SECURITY: Protected content only rendered when access is granted */}
      {hasAccess && (
        <div class="protected-content">
        {isCollection && subAlbums.length > 0 && (
          <div class="section">
            <div class="section-header albums-header">
              <h2>Albums</h2>
              <select id="album-sort" class="control-select" title="Sort albums">
                <option value="custom">Custom Order</option>
                <option value="name-asc">Name (A-Z)</option>
                <option value="name-desc">Name (Z-A)</option>
                <option value="date-newest">Date (Newest)</option>
                <option value="date-oldest">Date (Oldest)</option>
              </select>
            </div>
            <AlbumGrid albums={subAlbumsWithCovers} />
          </div>
        )}

        {photos.length > 0 && (
          <div class="section">
            <div class="section-header">
              <div class="section-title-wrapper">
                <h2>({photoCount}/{videoCount})</h2>
                <div class="gallery-controls">
                  <select id="sort-select" class="control-select" title="Sort photos" data-album-sort={album.data.sort}>
                    <option value="date-oldest">Date (Oldest)</option>
                    <option value="date-newest">Date (Newest)</option>
                    <option value="exif-oldest">EXIF Date (Oldest)</option>
                    <option value="exif-newest">EXIF Date (Newest)</option>
                    <option value="name-asc">Name (A-Z)</option>
                    <option value="name-desc">Name (Z-A)</option>
                    <option value="size-largest">Size (Largest)</option>
                    <option value="size-smallest">Size (Smallest)</option>
                  </select>
                  <select id="style-select" class="control-select" title="Display style" data-album-style={album.data.style}>
                    <option value="grid">Grid</option>
                    <option value="masonry">Masonry</option>
                    <option value="single-column">Single Column</option>
                  </select>
                  {hasVideos && (
                    <div class="media-filter" role="radiogroup" aria-label="Filter media type" data-video-count={videoCount}>
                      <div class="media-filter-track">
                        <div class="media-filter-indicator"></div>
                      </div>
                      <button class="media-filter-option active" role="radio" aria-checked="true" data-filter="photos">
                        <span class="media-filter-label">Photos</span>
                        <span class="media-filter-count" data-count="photos">{photoCount}</span>
                      </button>
                      <button class="media-filter-option" role="radio" aria-checked="false" data-filter="videos">
                        <span class="media-filter-label">Videos</span>
                        <span class="media-filter-count" data-count="videos">{videoCount}</span>
                      </button>
                    </div>
                  )}
                </div>
              </div>
              {album.data.allowDownload && (
                <button class="download-all" data-album-path={path}>
                  Download Album
                </button>
              )}
            </div>
            <PhotoGrid
              photos={photos}
              style={album.data.style}
              albumPath={path!}
              albumToken={album.data.token}
              isProtected={hasPasswordProtection}
              hasAccess={hasAccess}
            />
          </div>
        )}

        {archiveFiles.length > 0 && (
          <div class="section downloads-section">
            <h2>Downloads</h2>
            <div class="downloads-list">
              {archiveFiles.map(file => (
                <a href={file.url} download class="download-item">
                  <span class="download-icon">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                      <polyline points="7,10 12,15 17,10"/>
                      <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                  </span>
                  <span class="download-name">{file.filename}</span>
                  <span class="download-size">
                    {file.size < 1024 * 1024
                      ? `${(file.size / 1024).toFixed(0)} KB`
                      : file.size < 1024 * 1024 * 1024
                        ? `${(file.size / (1024 * 1024)).toFixed(1)} MB`
                        : `${(file.size / (1024 * 1024 * 1024)).toFixed(2)} GB`
                    }
                  </span>
                </a>
              ))}
            </div>
          </div>
        )}

        {subAlbums.length === 0 && photos.length === 0 && archiveFiles.length === 0 && (
          <p class="empty">This album is empty. Add photos to the folder: src/content/albums/{path}</p>
        )}
        </div>
      )}
    </div>

    <Footer />
  </div>
</Layout>

<style>
  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 2rem 1rem;
  }

  .album-header {
    margin-bottom: 2rem;
  }

  h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    color: #333;
  }

  /* Album Description: short, inline markdown */
  .album-description {
    margin: 0.75rem 0 1rem;
    color: var(--color-text-secondary, #666);
    font-size: 1.05rem;
    line-height: 1.6;
  }

  .album-description :global(strong) {
    font-weight: 600;
    color: var(--color-text, #333);
  }

  .album-description :global(em) {
    font-style: italic;
  }

  .album-description :global(a) {
    color: var(--color-primary, #2563eb);
    text-decoration: underline;
    text-underline-offset: 2px;
  }

  .album-description :global(a:hover) {
    color: var(--color-hover, #1d4ed8);
  }

  /* Album Body: full article from body.md */
  .album-body {
    margin: 1.5rem 0 0;
    padding: 1.5rem 0;
    border-top: 1px solid var(--color-border, #e5e5e5);
  }

  /* Prose styles for markdown content */
  .prose {
    color: var(--color-text, #333);
    line-height: 1.8;
    max-width: 75ch;
  }

  .prose :global(h1),
  .prose :global(h2),
  .prose :global(h3),
  .prose :global(h4) {
    font-family: var(--font-heading, 'Syne', sans-serif);
    font-weight: 600;
    margin: 1.5em 0 0.75em;
    color: var(--color-text, #333);
  }

  .prose :global(h1) { font-size: 1.75rem; }
  .prose :global(h2) { font-size: 1.5rem; }
  .prose :global(h3) { font-size: 1.25rem; }
  .prose :global(h4) { font-size: 1.1rem; }

  .prose :global(p) {
    margin: 1em 0;
  }

  .prose :global(a) {
    color: var(--color-primary, #2563eb);
    text-decoration: underline;
    text-underline-offset: 2px;
  }

  .prose :global(a:hover) {
    color: var(--color-hover, #1d4ed8);
  }

  .prose :global(ul),
  .prose :global(ol) {
    margin: 1em 0;
    padding-left: 1.5em;
  }

  .prose :global(li) {
    margin: 0.5em 0;
  }

  .prose :global(blockquote) {
    border-left: 4px solid var(--color-primary, #2563eb);
    padding: 0.5em 0 0.5em 1.5em;
    margin: 1.5em 0;
    background: rgba(0, 0, 0, 0.02);
    font-style: italic;
    color: var(--color-text-secondary, #666);
  }

  .prose :global(code) {
    background: rgba(0, 0, 0, 0.05);
    padding: 0.2em 0.4em;
    border-radius: 4px;
    font-size: 0.9em;
    font-family: 'SF Mono', 'Fira Code', monospace;
  }

  .prose :global(pre) {
    background: #f5f5f5;
    padding: 1rem;
    border-radius: 8px;
    overflow-x: auto;
    margin: 1.5em 0;
  }

  .prose :global(pre code) {
    background: none;
    padding: 0;
  }

  .prose :global(img) {
    max-width: 100%;
    height: auto;
    border-radius: 8px;
    margin: 1em 0;
  }

  .prose :global(hr) {
    border: none;
    border-top: 1px solid var(--color-border, #e5e5e5);
    margin: 2em 0;
  }

  .prose :global(strong) {
    font-weight: 600;
  }

  .prose :global(em) {
    font-style: italic;
  }

  .date {
    color: #999;
    font-size: 0.95rem;
    margin-bottom: 1rem;
  }

  .tags {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .tag {
    background: #e3f2fd;
    color: #1976d2;
    padding: 0.25rem 0.75rem;
    border-radius: 16px;
    font-size: 0.85rem;
  }

  .section {
    margin-top: 3rem;
  }

  .section h2 {
    font-size: 1.75rem;
    margin-bottom: 1rem;
    color: #444;
  }

  .albums-header h2 {
    margin-bottom: 0;
  }

  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    gap: 1rem;
  }

  .section-title-wrapper {
    display: flex;
    align-items: center;
    gap: 2rem;
    flex-wrap: wrap;
  }

  .section-title-wrapper h2 {
    margin: 0;
  }

  .gallery-controls {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .control-select {
    padding: 0.5rem 2rem 0.5rem 0.75rem;
    border: 1px solid #ddd;
    border-radius: 6px;
    background: white;
    font-size: 0.9rem;
    color: #333;
    cursor: pointer;
    transition: border-color 0.2s;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%23666' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.5rem center;
  }

  .control-select:hover {
    border-color: #999;
  }

  .control-select:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
  }

  /* Media Filter Toggle */
  .media-filter {
    --filter-height: 36px;
    --filter-radius: 6px;
    --filter-bg: #f5f5f5;
    --filter-active-bg: #ffffff;
    --filter-text: #666666;
    --filter-text-active: #1a1a1a;
    --filter-count: #999999;
    --filter-count-active: #666666;
    --filter-border: rgba(0, 0, 0, 0.08);
    --filter-shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.06);
    --transition-duration: 0.25s;
    --transition-ease: cubic-bezier(0.4, 0, 0.2, 1);

    position: relative;
    display: inline-flex;
    align-items: center;
    height: var(--filter-height);
    padding: 3px;
    background: var(--filter-bg);
    border-radius: var(--filter-radius);
    gap: 2px;
  }

  .media-filter-track {
    position: absolute;
    inset: 3px;
    pointer-events: none;
    overflow: hidden;
    border-radius: calc(var(--filter-radius) - 2px);
  }

  .media-filter-indicator {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: calc(100% / 2);
    background: var(--filter-active-bg);
    border-radius: calc(var(--filter-radius) - 2px);
    box-shadow: var(--filter-shadow);
    border: 1px solid var(--filter-border);
    transition: transform var(--transition-duration) var(--transition-ease);
    will-change: transform;
  }

  /* Photos is at position 0, no transform needed (default) */

  .media-filter:has([data-filter="videos"].active) .media-filter-indicator {
    transform: translateX(100%);
  }

  .media-filter-option {
    position: relative;
    z-index: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.35em;
    height: 100%;
    padding: 0 12px;
    background: transparent;
    border: none;
    border-radius: calc(var(--filter-radius) - 2px);
    font-family: inherit;
    font-size: 0.85rem;
    font-weight: 500;
    letter-spacing: -0.01em;
    color: var(--filter-text);
    cursor: pointer;
    transition: color var(--transition-duration) var(--transition-ease);
    white-space: nowrap;
    -webkit-tap-highlight-color: transparent;
    min-width: 44px;
  }

  .media-filter-option:hover:not(.active) {
    color: var(--filter-text-active);
  }

  .media-filter-option.active {
    color: var(--filter-text-active);
  }

  .media-filter-option:focus-visible {
    outline: 2px solid var(--color-primary, #2563eb);
    outline-offset: 1px;
  }

  .media-filter-label {
    transition: transform var(--transition-duration) var(--transition-ease);
  }

  .media-filter-option:active .media-filter-label {
    transform: scale(0.97);
  }

  .media-filter-count {
    font-size: 0.75rem;
    font-weight: 400;
    color: var(--filter-count);
    opacity: 0.9;
    transition: color var(--transition-duration) var(--transition-ease),
                opacity var(--transition-duration) var(--transition-ease);
  }

  .media-filter-option.active .media-filter-count {
    color: var(--filter-count-active);
    opacity: 1;
  }

  .download-all {
    background: var(--color-primary);
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 6px;
    font-size: 0.95rem;
    transition: background 0.2s;
  }

  .download-all:hover {
    background: var(--color-hover);
  }

  /* Downloads Section */
  .downloads-section {
    margin-top: 2rem;
  }

  .downloads-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-top: 1rem;
  }

  .download-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.875rem 1rem;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    text-decoration: none;
    color: var(--color-text, #333);
    transition: all 0.2s ease;
  }

  .download-item:hover {
    background: #e9ecef;
    border-color: #dee2e6;
    transform: translateX(4px);
  }

  .download-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    background: var(--color-primary, #2563eb);
    color: white;
    border-radius: 6px;
    flex-shrink: 0;
  }

  .download-name {
    flex: 1;
    font-weight: 500;
    font-size: 0.95rem;
    word-break: break-word;
  }

  .download-size {
    font-size: 0.85rem;
    color: #6c757d;
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
  }

  .empty {
    padding: 3rem;
    text-align: center;
    color: #999;
    background: #f5f5f5;
    border-radius: 8px;
  }

  /* Password Protection Form (SSR) */
  .password-protection {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 400px;
    padding: 2rem;
  }

  .password-form {
    background: white;
    border: 1px solid var(--color-border, #e5e5e5);
    border-radius: 12px;
    padding: 3rem;
    max-width: 400px;
    width: 100%;
    text-align: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .lock-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
  }

  .password-form h2 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
    color: #333;
  }

  .password-form p {
    color: #666;
    margin-bottom: 1rem;
  }

  .password-form .blocking-info {
    font-size: 0.9rem;
    color: #856404;
    background: #fff3cd;
    padding: 0.75rem;
    border-radius: 6px;
    margin-bottom: 1rem;
  }

  .password-form .error-message {
    color: #d32f2f;
    font-size: 0.9rem;
    margin-bottom: 1rem;
    background: #ffebee;
    padding: 0.75rem;
    border-radius: 6px;
  }

  .password-form form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-top: 1rem;
  }

  .password-form input[type="password"] {
    padding: 0.75rem 1rem;
    border: 1px solid var(--color-border, #e5e5e5);
    border-radius: 6px;
    font-size: 1rem;
    font-family: inherit;
  }

  .password-form input[type="password"]:focus {
    outline: none;
    border-color: var(--color-primary, #2563eb);
  }

  .password-form button[type="submit"] {
    padding: 0.75rem 1.5rem;
    background: var(--color-primary, #2563eb);
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.2s;
  }

  .password-form button[type="submit"]:hover {
    background: var(--color-hover, #1d4ed8);
  }

  @media (max-width: 768px) {
    .password-form {
      padding: 2rem;
    }
  }

  @media (max-width: 768px) {
    h1 {
      font-size: 1.75rem;
    }

    .section h2 {
      font-size: 1.5rem;
    }

    .section-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 1rem;
    }

    .section-title-wrapper {
      width: 100%;
      flex-direction: column;
      align-items: flex-start;
      gap: 1rem;
    }

    .gallery-controls {
      width: 100%;
      gap: 0.5rem;
    }

    .control-select {
      flex: 1;
      min-width: 0;
    }

    .gallery-controls {
      flex-wrap: wrap;
    }

    .media-filter {
      --filter-height: 40px;
      width: 100%;
      justify-content: center;
    }

    .media-filter-option {
      flex: 1;
      padding: 0 8px;
      font-size: 0.8rem;
    }

    .media-filter-count {
      font-size: 0.7rem;
    }

    .download-all {
      width: 100%;
    }
  }

  @media (max-width: 400px) {
    .media-filter-count {
      display: none;
    }
  }
</style>

<script>
  // SECURITY: Access control is now handled server-side (SSR)
  // This script only handles UI features: sorting, display style, media filter, download
  document.addEventListener('DOMContentLoaded', () => {
    const albumContent = document.getElementById('album-content');
    const albumPath = albumContent?.dataset.albumPath;
    const albumToken = albumContent?.dataset.albumToken;
    const hasAccess = albumContent?.dataset.hasAccess === 'true';

    // Only initialize UI controls if we have access (content is rendered)
    if (!hasAccess) return;

    // Initialize sorting and display style functionality
    function initializeSorting() {
      const sortSelect = document.getElementById('sort-select') as HTMLSelectElement;
      const styleSelect = document.getElementById('style-select') as HTMLSelectElement;
      const photoGallery = document.getElementById('photo-gallery');

      if (sortSelect && photoGallery) {
        // Map schema sort values to frontend sort values
        const sortMapping: Record<string, string> = {
          'date-desc': 'date-newest',
          'date-asc': 'date-oldest',
          'exif-desc': 'exif-newest',
          'exif-asc': 'exif-oldest',
          'name': 'name-asc',
          'custom': 'name-asc'
        };

        // Get album's default sort from data attribute
        const albumSort = sortSelect.dataset.albumSort || 'date-desc';
        const defaultSort = sortMapping[albumSort] || 'date-oldest';

        // Load saved sort preference or use album's default
        const savedSort = localStorage.getItem('photo-sort-preference');

        if (savedSort) {
          sortSelect.value = savedSort;
          sortPhotos(savedSort);
        } else {
          sortSelect.value = defaultSort;
          sortPhotos(defaultSort);
        }

        sortSelect.addEventListener('change', (e) => {
          const sortValue = (e.target as HTMLSelectElement).value;
          localStorage.setItem('photo-sort-preference', sortValue);
          sortPhotos(sortValue);
        });

        function sortPhotos(sortBy: string) {
          const photoItems = Array.from(photoGallery.querySelectorAll('.photo-item'));

          if (photoItems.length === 0) {
            return;
          }

          photoItems.sort((a, b) => {
            const filenameA = a.getAttribute('data-photo-filename') || '';
            const filenameB = b.getAttribute('data-photo-filename') || '';

            switch (sortBy) {
              case 'name-asc':
                return filenameA.localeCompare(filenameB);

              case 'name-desc':
                return filenameB.localeCompare(filenameA);

              case 'date-newest':
              case 'date-oldest': {
                const dateA = parseInt(a.getAttribute('data-photo-mtime') || '0');
                const dateB = parseInt(b.getAttribute('data-photo-mtime') || '0');
                return sortBy === 'date-newest' ? dateB - dateA : dateA - dateB;
              }

              case 'exif-newest':
              case 'exif-oldest': {
                const exifA = parseInt(a.getAttribute('data-photo-exif-date') || '0');
                const exifB = parseInt(b.getAttribute('data-photo-exif-date') || '0');
                // Photos without EXIF date (0) should sort to the end
                if (exifA === 0 && exifB === 0) return 0;
                if (exifA === 0) return 1;  // a has no EXIF, sort to end
                if (exifB === 0) return -1; // b has no EXIF, sort to end
                return sortBy === 'exif-newest' ? exifB - exifA : exifA - exifB;
              }

              case 'size-largest':
              case 'size-smallest': {
                const sizeA = parseInt(a.getAttribute('data-photo-size') || '0');
                const sizeB = parseInt(b.getAttribute('data-photo-size') || '0');
                return sortBy === 'size-largest' ? sizeB - sizeA : sizeA - sizeB;
              }

              default:
                return 0;
            }
          });

          // Reorder DOM elements
          photoItems.forEach(item => photoGallery.appendChild(item));
        }
      }

      // Initialize display style
      if (styleSelect && photoGallery) {
        const albumStyle = styleSelect.dataset.albumStyle || 'grid';
        const savedStyle = localStorage.getItem('photo-display-style');

        // Use saved style or fall back to album's configured style
        const currentStyle = savedStyle || albumStyle;
        styleSelect.value = currentStyle;
        applyDisplayStyle(currentStyle);

        styleSelect.addEventListener('change', (e) => {
          const styleValue = (e.target as HTMLSelectElement).value;
          localStorage.setItem('photo-display-style', styleValue);
          applyDisplayStyle(styleValue);
        });

        function applyDisplayStyle(style: string) {
          // Remove all style classes
          photoGallery.classList.remove('photo-grid-grid', 'photo-grid-masonry', 'photo-grid-slideshow', 'photo-grid-single-column');
          // Add the new style class
          photoGallery.classList.add(`photo-grid-${style}`);
        }
      }

      // Initialize media filter
      initMediaFilter();
    }

    // Media Filter Toggle
    function initMediaFilter() {
      const filter = document.querySelector('.media-filter') as HTMLElement;
      if (!filter) return;

      const options = filter.querySelectorAll('.media-filter-option');
      const gallery = document.getElementById('photo-gallery');
      const styleSelect = document.getElementById('style-select') as HTMLSelectElement;

      // Filter items (photos or videos only, no 'all' option)
      function filterItems(filterType: string) {
        const items = gallery?.querySelectorAll('.photo-item') || [];

        items.forEach(item => {
          const isVideo = (item as HTMLElement).dataset.isVideo === 'true';

          if (filterType === 'videos') {
            (item as HTMLElement).style.display = isVideo ? '' : 'none';
          } else {
            // Default to photos filter
            (item as HTMLElement).style.display = isVideo ? 'none' : '';
          }
        });

        // Auto-switch to single-column for videos only
        if (filterType === 'videos' && styleSelect) {
          styleSelect.value = 'single-column';
          styleSelect.dispatchEvent(new Event('change'));
        }
      }

      // Handle option clicks
      options.forEach(option => {
        option.addEventListener('click', () => {
          // Update active states
          options.forEach(opt => {
            opt.classList.remove('active');
            opt.setAttribute('aria-checked', 'false');
          });
          option.classList.add('active');
          option.setAttribute('aria-checked', 'true');

          // Apply filter
          const filterType = (option as HTMLElement).dataset.filter || 'all';
          filterItems(filterType);

          // Store preference
          localStorage.setItem('photo-media-filter', filterType);
        });
      });

      // Keyboard navigation
      filter.addEventListener('keydown', (e) => {
        const currentOption = filter.querySelector('.media-filter-option.active');
        const optionsArray = Array.from(options);
        const currentIndex = currentOption ? optionsArray.indexOf(currentOption) : 0;

        let newIndex = currentIndex;

        if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
          e.preventDefault();
          newIndex = (currentIndex + 1) % optionsArray.length;
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          e.preventDefault();
          newIndex = (currentIndex - 1 + optionsArray.length) % optionsArray.length;
        }

        if (newIndex !== currentIndex) {
          (optionsArray[newIndex] as HTMLElement).click();
          (optionsArray[newIndex] as HTMLElement).focus();
        }
      });

      // Restore saved filter or default to 'photos'
      const savedFilter = localStorage.getItem('photo-media-filter');
      // Only restore 'videos' filter; otherwise default to 'photos'
      if (savedFilter === 'videos') {
        const savedOption = filter.querySelector(`[data-filter="videos"]`) as HTMLElement;
        if (savedOption) {
          savedOption.click();
        }
      } else {
        // Apply photos filter on page load (hide videos by default)
        filterItems('photos');
        localStorage.setItem('photo-media-filter', 'photos');
      }
    }

    // Initialize UI controls (access already verified server-side)
    initializeSorting();

    // Auto-open lightbox if ?photo= parameter is present (shared photo link)
    const sharedPhoto = albumContent?.dataset.sharedPhoto;
    if (sharedPhoto) {
      // Wait for PhotoSwipe to initialize, then open to the specific photo
      setTimeout(() => {
        const photoItems = document.querySelectorAll('.photo-item');
        const photoIndex = Array.from(photoItems).findIndex(
          item => (item as HTMLElement).dataset.photoFilename === sharedPhoto
        );

        if (photoIndex >= 0) {
          // Find the lightbox trigger and simulate a click
          const photoLink = photoItems[photoIndex].querySelector('a[data-pswp-src]');
          if (photoLink) {
            (photoLink as HTMLElement).click();
          }
        }
      }, 500);
    }

    // Initialize album sorting (for sub-albums in collections)
    function initializeAlbumSorting() {
      const albumSortSelect = document.getElementById('album-sort') as HTMLSelectElement;
      if (!albumSortSelect) return;

      const albumGrid = document.querySelector('.album-grid');
      if (!albumGrid) return;

      // Load saved sort preference
      const savedSort = localStorage.getItem('photoGallery_albumSort') || 'custom';
      albumSortSelect.value = savedSort;
      sortAlbums(savedSort);

      albumSortSelect.addEventListener('change', () => {
        const sortValue = albumSortSelect.value;
        sortAlbums(sortValue);
        localStorage.setItem('photoGallery_albumSort', sortValue);
      });

      function sortAlbums(sortBy: string) {
        const cards = Array.from(albumGrid.querySelectorAll('.album-card')) as HTMLElement[];

        cards.sort((a, b) => {
          const titleA = a.dataset.title || '';
          const titleB = b.dataset.title || '';
          const dateA = parseInt(a.dataset.date || '0', 10);
          const dateB = parseInt(b.dataset.date || '0', 10);
          const orderA = parseInt(a.dataset.order || '999', 10);
          const orderB = parseInt(b.dataset.order || '999', 10);

          switch (sortBy) {
            case 'name-asc':
              return titleA.localeCompare(titleB);
            case 'name-desc':
              return titleB.localeCompare(titleA);
            case 'date-newest':
              if (!dateA && !dateB) return 0;
              if (!dateA) return 1;
              if (!dateB) return -1;
              return dateB - dateA;
            case 'date-oldest':
              if (!dateA && !dateB) return 0;
              if (!dateA) return 1;
              if (!dateB) return -1;
              return dateA - dateB;
            case 'custom':
            default:
              if (orderA !== orderB) return orderA - orderB;
              return titleA.localeCompare(titleB);
          }
        });

        cards.forEach(card => albumGrid.appendChild(card));
      }
    }

    initializeAlbumSorting();

    // Download album button
    const downloadBtn = document.querySelector('.download-all');
    downloadBtn?.addEventListener('click', async (e) => {
      const downloadPath = (e.target as HTMLElement).dataset.albumPath;
      const btn = e.target as HTMLButtonElement;
      const originalText = btn.textContent;

      btn.disabled = true;
      btn.textContent = 'Preparing download...';

      try {
        // Build headers - include token for password-protected albums
        const headers: Record<string, string> = { 'Content-Type': 'application/json' };
        if (albumToken) {
          headers['X-Album-Token'] = albumToken;
        }

        const response = await fetch('/api/download-album', {
          method: 'POST',
          headers,
          body: JSON.stringify({ albumPath: downloadPath })
        });

        if (!response.ok) {
          throw new Error('Download failed');
        }

        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${downloadPath?.split('/').pop() || 'album'}.zip`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);

        btn.textContent = originalText;
        btn.disabled = false;
      } catch (error) {
        console.error('Download error:', error);
        btn.textContent = 'Download failed';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.disabled = false;
        }, 2000);
      }
    });
  });
</script>
